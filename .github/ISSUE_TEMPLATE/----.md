---
name: 작업일지
about: 공부 내용, 트러블 슈팅, 작업 내역
title: ""
labels: ""
assignees: ""
---

# 공부한 것

## Jest 입문하기

백엔드 쪽으로 잠시 넘어와 볼까 해서, 백엔드 작업을 시작하였다. npm 으로 시작하고 여기도 역시 테스트부터 시작하기로 하였는데, 컨트랙트에서 작성한 함수들(아직 초기 단계지만)을 백엔드 측에서 호출하는 기능을 만들려고 하였고 테스트부터 쓰기 시작했다.  
이번에는 **Jest**를 써 보기로 하였다. 구매한 Node.js 책에서 소개된 것으로 보고 쓰기로 마음 먹었는데 유용한 기능이 많아보였다. jest는 mocha와 비슷한 것 같았다.

### 라우터 유닛 테스트

내가 테스트하려는 것은 어떤 함수의 기능으로, 이 함수는 나중에 express router로 분리된 라우터에서 엔드포인트에 따라서 접근하게 되는 요청에 대해서 그 기능을 수행하게 될 것이다. 라우터는 미들웨어니까, 즉 주어진 엔드포인트와 콜백 함수를 연결하는 역할을 하는데 이 콜백 함수를 유닛 테스트 하기 위해서 함수를 분리하게 되면서 이런 구조를 가지게 되었다.

- 따라서 controllers라는 폴더를 만들어서 (라우터에서 응답하는 미들웨어를 컨트롤러라고 부른다고 한다) 함수를 작성하고,
- 작성한 함수를 export 한 후 route에 import 하고,
- route에서는 분기만 하고 필요한 함수를 가져다가 쓴다.

controllers 폴더로 관리하는 이유가 무엇인가 했는데 테스트를 위해서였나?? (그리고 가독성 때문이기도 하겠지)

어쨋든 시작은 다음과 같았다. 새로운 지갑을 생성하는 컨트랙트의 함수를 호출 할 **createWallet이라는 함수**를 import 해 오고, describe, test 구조는 mocha에서 익힌 것이라 바로 쓸 수 있었다. 블록체인 요청이 포함되어 있으므로 비동기 프로그래밍을 다루기 위해서 async 를 지정했다. 그리고 테스트 내에서 해당 함수를 호출할 것이다. **(물론 함수는 아직 만들어지지 않은 상태!!!)**

```js
// 함수는 아직 안 만들었음, 테스트 먼저 만듦
const { createWallet } = require("../controllers/wallet");

describe("wallet", () => {
  test("createNewWallet", async () => {
    await createWallet(req, res);
  });
});
```

그럼 이제 어떨까? 저 함수가 제대로 작동하면 status 201을 반환하고, 아니면 status 404를 반환하게 짜야 겠지? 한 줄 추가했다.

```js
describe("wallet", () => {
  test("createNewWallet", async () => {
    await createWallet(req, res);
    expect(res.status).toBeCalledWith(201);
  });
});
```

그런데 문제가 있다. 저 req, res를 정의해 줘야 하는데 res는 express 객체이다. 그럼 그걸 여기에다가 구현해야 하나?

### mocking

그래서 jest에서는 가짜 함수, 객체를 만들어 넣을 수 있는 모킹을 제공했다. 이 부분이 사실 헷갈리는데 읽고 있던 책에서 그래도 정보를 많이 얻었다. 저 res를 생각해 보자. 저것은 express 객체이고, status 와 send 등 메서드(함수)를 가지고 있을 것이다. 그게 정확히 뭔 지는 모르겠지만 **어쨌든 테스트가 성공하면 res 객체의 status 메서드가 201 이라는 인자를 가지고 호출될 것이다.**

따라서 그냥 가짜를 넣어 두어도 상관이 없다. 가짜 res 객체는 status와 send를 메서드로 가지는데 (실제로는 더 많지만 당연히 가짜이므로 필요한 것만 쓰면 된다.) 그 status와 send는 **jest.fn()** 모킹 함수를 값으로 가진다. status 처럼 안데 화살표 함수로 반환값을 넣을 수도 있는데 status는 메서드 체이닝을 위해서 res 객체를 반환하므로 해당 부분을 구현한 것이다.

그래서 res.status 라는 메서드가 201 status와 함께 불리는지만 체크한다.

```js
const { createWallet } = require("../controllers/wallet");

describe("wallet", () => {
  const res = {
    status: jest.fn(() => res),
    send: jest.fn(),
  };

  test("createNewWallet", async () => {
    await createWallet(req, res);
    expect(res.status).toBeCalledWith(201);
  });
});
```

그럼 res는 되었고, req는 어떻게 할 까? req는 직접 써주면 되었다. req.body에 들어간 값을 토대로 컨트랙트 함수를 호출할 것이므로, req 객체 안에 body를 설정하여 필요한 값을 넣어주었다.

```js
test("createNewWallet", async () => {
  req = {
    body: [
      "0x59aE440c95eDe66F5050c969E0Aeaa4b739f6418",
      "0x80EA4745538cf861E36672450bF8fC9459277D6c",
    ],
  };
  await createWallet(req, res);
  expect(res.status).toBeCalledWith(201);
});
```

## web3으로 테스트하기

일단 간단한 테스트를 작성했고, 그에 맞는 함수를 이제 작성해야 했다. 이 함수는 배포된 컨트랙트의 함수를 호출하고, 그 결과에 따라서 상태 코드나 뭐 필요한 정보를 리턴할 것이다. 이 작업을 위해서 web3.js를 사용하였다. 일단 설치하고

```bash
$ npm i web3
```

이게 저번에 했었는데도 영 헷갈린다. 순서는 다음과 같았다.

- web3 import 하고 rpcURL설정해 주기 (지금 연결되어 있는 네트워크 제공자?? 좀 자세히 봐야 할 듯)
- 먼저 컨트랙트의 ABI가 필요하다. ABI는 리믹스에서 가져오고 따로 모듈로 만들어서 import했다.
- 그리고 네트워크에 컨트랙트를 배포하고 그 컨트랙트 주소가 필요하다.
- 이 두가지가 있으면 특정 컨트랙트의 정보를 가진 객체를 만들 수 있다. web3.eth.Contract(abi, address) 형태로 만들고 변수에 객체를 할당했다.
- 이제 식별자.methods.컨트랙트함수이름().call()(또는send())로 함수를 js에서 실행시킬 수 있다.

여기까지 해서 컨트랙트의 함수를 실행시키는 함수를 만들면 다음과 같다. 이게 나중에 미들웨어의 콜백으로 쓰이게 될 것이다.

```js
const Web3 = require("web3");
const rpcURL = "http://localhost:8545";
const web3 = new Web3(rpcURL);

const abi = require("../abi/MultiSigWalletFactoryABI");
const address = "0x0e2a98CA25d8275b9e5591288D795f5035E6BF06";

const NameContract = new web3.eth.Contract(abi, address);

exports.createWallet = async (req, res) => {
  const result = await NameContract.methods.createWallet(req.body).call(); // 컨트랙트의 createWallet
};
```

에러가 날 수 있으니 try-catch를 쓰고 결과에 따른 응답을 분기해 주면 되었다.

```js
exports.createWallet = async (req, res) => {
  try {
    const result = await NameContract.methods.createWallet(req.body).call();
    if (result) {
      res.status(201).send("success createWallet", { data: result });
    } else {
      res.status(404).send("wrong");
    }
  } catch (error) {
    console.error(error);
  }
};
```

## call()과 send()

이것 때문에 해멨는데 다른 컨트랙트 함수 호출하는 작업하면서 알게 된 것으로 web3으로 함수 호출할 때 함수 뒤에 call()이나 send()를 붙여서 호출할 수가 있는데 이 둘은 차이점이 있다.

- call : 컨트랙트의 state를 변화시키지 않을 때 사용한다.
- send : 컨트랙트의 state를 **변화시켜야 할 때** 사용한다.

간단하기는 한데 저 둘을 혼용하면 안된다. send()를 써야할 자리에 call()을 잘못 쓰면 트랜잭션을 보내지 않아서(?) 제대로 된 결과를 받을 수가 없고, call()을 써야할 자리에 send()를 쓰면 revert 에러가 뜬다. 근데 그냥 컨트랙트 오류일때랑 같은 오류가 떠서 send() 때문이라는 것을 에러 메시지로 알 수가 없어서 컨트랙트에 문제가 있나 하고 엄한데를 들여다 보내고 있었다.

정확히 왜 저런 차이가 벌어지는지는 잘 이해 못했는데 하여튼 잘 구분해야 한다.

# 해야할 일

- [ ] RPC란 무엇인가?
- [ ] res.send의 반환값 다루는 법 찾아보기 (내가 {data: result}로 했던 거)
- [ ] 몽고디비 설치 문제 해결. 몽고 디비 써볼려고 깔았는데 뭐가 또 안된다... mysql때도 작동이 계속 안되서 결국 맥북 초기화까지 했는데 이건 또 왜이러냐 열받는다
- [ ] truffle test를 web3 기반으로 수정할 것인가?
- [ ] 코드 완전 넝마가 되서 한 번 깔끔하게 다듬고 가야 할 듯.
- [ ] 다음 주간은 순공 40시간까지 늘려보기 (이번 주 34시간)
