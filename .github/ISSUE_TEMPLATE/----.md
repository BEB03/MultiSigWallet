---
name: 작업일지
about: 공부 내용, 트러블 슈팅, 작업 내역
title: ''
labels: ''
assignees: ''
---

# 코드 컨벤션

## ESLint

js 책을 읽다가 eslint에 대해서 알게 되었다. 이것은 소스코드 실행 전에 스캔하여 오류를 찾아내고 원인을 알려주는 도구라고 되어 있었다. 좀 더 서치해보니 코드 품질을 위해서 사용하는 것이 좋다고 하여서 오늘 도전해보았다.

ESLint
일단 npm으로 설치한다.

```bash
npm i -D eslint
```

그리고 vscode에서 eslint extensions를 설치해 준다.

둘 다 했으면 설정을 해 주어야 한다. 설정은 프로젝트 루트 디렉토리에 .eslintrc 파일을 만들어 주어야 한다. 이 파일은 js나 json, YAML등의 포맷으로 지원이 된다. 나는 js 파일로 써 보기로 하였다. 직접 .eslintrc.js 파일을 생성해도 되고, 다음 명령어로 만들 수도 있다. (이 경우 몇 가지 기본 설정을 cli로 쉽게 할 수 있었음)

```bash
npx eslint --init
```

다음과 같은 파일을 만들었다. env 옵션은 eslint가 전역 객체를 선언하지 않은 변수로 인식해서 오류가 나게 되는데 그것을 가려주는 역할을 하는 것이다. 예를 들어서 test에서 mocha의 it 같은거, extends 옵션은 규칙이 설정되어 있는 외부 파일을 적용하는 것이다. 나는 에어비앤비 스타일의 규칙을 적용해 보았다. (npm으로 플러그인 따로 설치해야함) 그다음 파서옵션, 추가 규칙을 정할 수 있는 룰 등 옵션은 이것저것 있으므로 필요한 것을 사용하면 되었다.

근데 truffle 을 env에 적용하니 다른 지적 사항도 같이 가려져 버리는 현상이 있다. 이것만 이러는 건지 뭔지...

```js
module.exports = {
  env: {
    browser: true,
    node: true,
    commonjs: true,
    es2021: true,
    // mocha: true,
    // truffle: true,
  },
  extends: ['airbnb-base'],
  parserOptions: {
    ecmaVersion: 'latest',
  },
  rules: {},
};
```

## Prettier

프리티어는 vscode 익스텐션으로 이미 사용하고 있었다. 이것도 코드 컨벤션을 용이하게 해주는 툴인데 eslint 와는 좀 다르게 코트 포매팅을 중점적으로 위한 툴이다. 줄바꿈이나 콤마, 스페이스, 개행 같은 스타일을 일정하게 유지함으로써 코드를 보기 좋게 만들어준다.

뭐라 딱 잘라 말하기가 좀 그런데 eslint는 **코드를 안정적이고 좋은 품질**로 만들어주고, 프리티어는 **코드 가독성을 높여주는 툴**이라고 생각되었다.

### 직접 설치하기

이미 vscode extension으로 사용하고 있었지만 eslint를 한 김에 이것도 npm으로 설치하고 파일 생성으로 규칙을 적용해 보기로 하였다. 이 경우 내 로컬 vscode 에서만 적용한 것과 다르게 다른 사람이 이 코드를 받아서 쓰는 경우에도 같은 프리티어 설정을 일괄적으로 적용할 수 있다는 장점이 있다.

역시 npm으로 설치를 한다.

```bash
npm i -D prettier
```

이제 eslint에서 하던 것처럼 .prettierrc 파일을 만들어서 규칙을 정해주면 되는데, 파일을 만들지 않는 경우 기본값으로 세팅이 된다고 한다. 나는 따로 파일을 만들지는 않았다. 뒤에 자동 실행 파트에서 이미 있던 익스텐션과 겹쳐 헷갈려서 집중력 저하로 직접 설치하는 방법은 나중에 다시 시도하기로 했다.

### eslint-config-prettier

프리티어에서는 eslint를 사용중일 경우 해당 패키지를 사용해서 충돌이 일어나지 않게끔 하라고 하고 있다. 사용을 위해서 먼저 설치하고,

```bash
npm install --save-dev eslint-config-prettier
```

.eslintrc 파일의 extend 항목에서 프리티어를 추가해 주면 된다. 항목 중에 **마지막에 프리티어를 추가**하라고 강조되어 있음. 이렇게 하면 둘이 충돌하는 부분에서는 eslint 규칙이 꺼지게 된다.

```js
module.exports = {
  extends: ['airbnb-base', 'prettier'],
};
```

### vscode 설정

이제 사용할 수 있지만, 내가 원하는 저장시마다 자동으로 적용이 되게 하는 것은 vscode에서 따로 설정을 해 주어야 한다.

command+shift+p 로 검색창을 열어서 open user settings (json)으로 들어가 준다. 그러면 루트 디렉토리에 폴더와 settings.json이 생겨서 여기서 설정을 해 주면 된다.

```json
// settings.json
{
  "editor.codeActionsOnSave": { "source.fixAll.eslint": true },
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode"
}
```

첫줄은 이름에서 알수 있듯 eslint 적용 사항으로 저장시 변경해준다. 밑의 두 줄은 프리티어가 저장시 작동하도록 하는 코드이다.

여기까지 마치고 사용해보니 잘 작동이 되었다. 이제 다음과 같은 상태가 적용된 것이다.

- ESLint 적용됨
- prettier 적용됨
- 충돌하는 부분에서는 ESLint 규칙을 끔
- 저장시 Eslint, Prettier 규칙 자동 적용

이로써 코드컨벤션을 갖추기 위한 기본적인 준비를 끝냈다.

# 솔리디티

## view 함수

솔리디티 view 함수는 호출 시 가스비를 소모하지 않는데, 블록체인에 저장된 storage state를 읽기만 하는 함수이기 때문에 블록체인에 정보를 새로 기록하거나 수정하지 않기 때문이다.

하지만 view 함수가 다른 함수에 의해서 호출될 때에는 그렇지 않다고 한다.

```
    function executeTransaction(uint _transactionId) onlyOwners() public {
...
        require(checkConfirmation(_transactionId) ==  true); // view 함수 호출
...
    }

        function checkConfirmation (uint _transactionId) internal view returns (bool) {
        for (uint i=0; i<owners.length; i++) {
            if (!confirmation[_transactionId][owners[i]]) {
                return false;
            }
        }
        return true;
    }
```

왜냐하면 트랜잭션을 발생시키는 다른 함수에서 view를 내부 호출하면
결국 블록체인에 네트워크에 영향을 미치냐 미치지 않느냐에 따라서 결정된다고 보면 맞겠다.

어쨋든 트랜잭션을 실행하기 전에 모든 지갑 주인이 동의하였는지 로직을 짰는데 트랜잭션 실행 함수 내에서 확인하기에는 코드가 난잡해져서 내부 호출 view 함수를 따로 만들어서 확인했다. 따라서 이 view는 가스를 소모할 것이다. 참고하고 있는 튜토리얼에서는 일정 정족수를 채우는지를 확인하는 식 이었는데 나는 전부 동의했는지를 여부로 짰으므로 어쨋든 loop를 최소화하기 위해서 중간에 한 명이라도 동의하지 않았으면 바로 false, 모든 loop가 다 정상적으로 끝난 경우에만 true를 반환하게 하여 가스를 줄여 보려는 노력을 하였다.

### 어뷰징

그럼 view나 pure는 가스를 소모하지 않으니까 무한정 호출해서 계산력을 남용할 수 있지 않는가? 라는 질문이 있었다. 외국 사이트 등의 답변을 보면 view 함수 호출의 진행은 **on your node**에서 이루어지기 때문에 남용해도 해당 노드에만 부담이 가고 전체 이더리움 네트워크에는 부담이 가지 않기 때문에 상관없다는 논리의 답변이었다.  
이 **on your node**라는 것의 이해가 애매하다. 노드를 구축하지 않고도 view 함수를 호출할 수 있지 않은가? 만약 view 함수를 제공하는 컨트랙트가 있고 어떤 백엔드 요청으로 web3.js로 해당 함수를 부른다고 치면, 내가 지갑을 연결해서 view 함수를 호출하면 그 부담은 누가 지는가? 지갑 주인인 내가 지는 건가 뭐 어떻게 되는 건가  
또 내가 remix에 지갑을 연결하고 컨트랙트를 작성해서 다른 컨트랙트의 view 함수를 호출한다면 그 계산력의 부담은 누가 지는가? 뭔가 이더리움 작동 구조를 좀 더 파봐야 겠다는 생각이 든다.

- [ ] 프리티어 npm 으로 설치하는 방법 실습
- [ ] view 함수 어뷰징의 의문점 해결하기
