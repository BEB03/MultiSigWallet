---
name: 작업일지
about: 공부 내용, 트러블 슈팅, 작업 내역
title: ""
labels: ""
assignees: ""
---

# 공부한 것

## express 구조에 대한 생각

express 라우팅을 공부하면서 정리한 express 구조에 대해서 생각해 보았다. 공부한 특징들은 다음과 같다.

- app.listen()을 정의한 파일에서 모든 요청을 받는다.
- 요청은 위에서 아래로 진행하면서 미들웨어들을 거쳐간다.
- 미들웨어에서 할 일은 응답을 하거나 next()를 호출하는 것이다.

```js
const express = require("express");
const walletRouter = require("./routes/wallet");

const app = express();
app.set("port", process.env.PORT || 3000);

app.use(morgan("dev"));

app.use("/wallet", walletRouter);

app.use((req, res, next) => {
  const error = new Error(`${req.method} ${req.url} 라우터가 없습니다.`);
  error.status = 404;
  next(error);
});

app.use((err, req, res, next) => {
  console.log(err);
  res.status(500).send(err.message);
});

app.listen(app.get("port"), () => {
  console.log(app.get("port"), "에서 대기 중");
});
```

만약 '/' 주소로 요청을 보냈다고 하자. 그러면 이 요청은 라우터들을 위에서 아래로 거쳐간다. 가장 먼저 만나는 것은 다음과 같다. 따라서 이 요청은 morgan()이라는 미들웨어가 적용 되었다. 이것은 겉에는 없지만 내부적으로 next()를 호출해서 다음 라우터로 넘어간다.

```js
app.use(morgan("dev"));
```

다음 만나는 것은 '/wallet' 주소를 분기하는 라우터이다. 이는 '/'요청에는 해당사항이 없으므로 넘어간다.  
그 다음으로 에러를 발생시키는 라우터에 도착했다. 요청에 대한 응답이 없는 주소에는 에러를 발생시켰다. 그리고 라우터는 응답이나 next()를 호출해야 한다고 했다. 여기서는 응답하지 않으므로 next()를 호출해 다음 라우터로 넘어간다.

```js
app.use((req, res, next) => {
  const error = new Error(`${req.method} ${req.url} 라우터가 없습니다.`);
  error.status = 404;
  next(error);
});
```

마지막 라우터에 도착했다. 아까 발생한 에러를 받아서 최종적으로 err.message를 요청자에게 응답한다. 응답을 했으므로 next()를 호출할 필요는 없다.

```js
app.use((err, req, res, next) => {
  console.log(err);
  res.status(500).send(err.message);
});
```

결국 어딘가에서는 응답을 받아야 한다는 것이 중요했다.

## 라우팅 분기

이러한 흐름을 알고 나니 라우팅 분리에 대한 이해가 되었다. 저번에 할 때는 어디에 뭘 적어야 하지 헷갈렸는데...

나는 지갑에 대한 요청을 /wallet 의 주소로 받고 싶다. 이 요청에 대한 응답 로직을 짜야 하는데 이것을 http 모듈에서 하던 것 처럼 app.js에 모두 쓰고 if문으로 분기를 하는 것은 비효율적이고 보기에도 좋지 않다. express는 이 문제를 해결할 수 있다.

/wallet 으로 요청이 들어왔다고 해 보자. 이 또한 위에서부터 적용되므로 이 요청에 대해서 morgan()이 적용 될 것이고, 그 다음에는 app.use("/wallet", walletRouter); 가 실행이 된다.

```js
app.use(morgan("dev"));

app.use("/wallet", walletRouter);

app.use((req, res, next) => {
  const error = new Error(`${req.method} ${req.url} 라우터가 없습니다.`);
  error.status = 404;
  next(error);
});

app.use((err, req, res, next) => {
  console.log(err);
  res.status(500).send(err.message);
});
```

app.use같은 메서드의 두 번째 인자는 미들웨어로 이 미들웨어는 **req, res, next를 매개변수로 가지는 함수**이다. 따라서 저 말을 풀어쓰면 /wallet으로 들어오는 모든 요청에 대해서 walletRouter 라는 함수를 호출하겠다는 의미이다.

```js
app.use("/wallet", walletRouter);
```

오케이 그러면 walletRouter가 존재해야 가져다 쓸 것이니 그 함수를 정의할 차례다.
routes라는 폴더를 만들어서 wallet.js를 만들었다.

```js
// routes/wallet.js

const express = require("express");

const router = express.Router();

router.post("/" /* 미들웨어 = 함수가 들어가는 자리 */);

module.exports = router;
```

위 코드는 다음과 같이 해석할 수 있다. express 에서 라우팅을 담당할 express.Router() 객체를 불러온 후, 그 객체의 일부를 수정하고 다시 express.Router() 객체를 모듈로 내보내는 것이다.

### 컨트롤러

저 방법으로 app.js에서의 복잡함을 줄였지만 한 단계 더 나아갈 수 있다. routes 폴더의 파일에는 라우터들만 모아 두고 미들웨어(함수)를 따로 작성하면 어떨까?  
그래서 그 다음은 controllers 폴더를 만들어서 wallet.js를 만들었다.

```js
// controllers/wallet.js

... 블록체인 관련한 부분

module.exports.create = async (req, res) => {
  try {
    const result = await NameContract.methods.createWallet(req.body).call();
    if (result) {
      res.status(201).send("success create new Wallet", { data: result });
    } else {
      res.status(404).send("failure create new Wallet");
    }
  } catch (error) {
    console.error(error);
    next(error);
  }
};
```

create는 이름으로 함수를 만들어서 블록체인에 요청하는 로직을 만들었다. 성공한 경우 201 과 함께 해당 지갑 주소를 리턴하였다. 지금 보니까 저 else 부분은 꼭 필요한 것인지 의구심이 드네.  
어쨋든 성공한 경우 **send로 응답을 하였으므로** 일은 여기서 끝난다. 하지만 만약 에러가 뜬다면? 이 경우에도 응답을 하던 next()를 호출하던 한 가지를 해 주어야 한다. app.js에서 에러 처리 미들웨어를 작성해 두었으므로 next(error)을 해 주어서 마무리했다.

```js
app.use(morgan("dev"));

app.use("/wallet", walletRouter); // 여기서

app.use((req, res, next) => {
  const error = new Error(`${req.method} ${req.url} 라우터가 없습니다.`);
  error.status = 404;
  next(error);
});

app.use((err, req, res, next) => {
  // 여기로 이동한 것임
  console.log(err);
  res.status(500).send(err.message);
});
```

어쩃든 create 함수를 exports 하였고, routes에서 불러와서 미들웨어 자리에 넣어주면 된다.

```js
// routes/wallet.js

const express = require("express");

const router = express.Router();

const wallet = require("../controllers/wallet");

router.post("/", wallet.create);

module.exports = router;
```

이렇게 분기하면 좋은 점이 2개 있다. 먼저 미들웨어를 따로 테스트 할 수 있어서 최소 기능 별로 테스트틀 진행할 수 있고,  
인증 같은 중복되는 미들웨어를 사용할 때 이 또한 따로 모듈로 만들어서 각 라우터에 붙여서 쓰기만 하면 되므로 재사용성과 가독성이 높아진다.

```js
// routes/wallet.js
...

router.post("/", wallet.create, /* 인증 관련 미들웨어 */);

...
```

결국 express에서의 라우팅은 express.Router()라는 거대한 객체 안에 필요한 라우터들을 모듈로 추가하고, 그 라우터마다 필요한 미들웨어들을 또 한번 모듈로 따로 만들어 라우터에 추가하는 형식으로 이루어졌다.

- 요청 받는 곳(app.js) - 라우터(routes) - 미들웨어(controllers) 이 3가지 나누어진 구조

## mongoDB 실행

설치했는데 자꾸 zsh: command not found: mongo 오류로 너무 머리가 아팠다. 이것 저것 해 보다가 결국 해결은 했다.

```bash
vim ~/.zshrc
```

해당 파일에 다음을 입력, 저 경로는 mongod, mongos 파일이 있는 폴더의 경로임, 여기서 주의할 게 **mongodb-community 말고 mongodb-commuinity@버젼** 으로 되어있는 폴더를 적어야만 했다.

```bash
export PATH=$PATH:/opt/homebrew/opt/mongodb-community@5.0/bin
source ~/.zshrc

// 실행
mongo
```

뭔가 zsh가 몽고를 찾는 경로를 직접 설정해주어야 할 필요가 있는 경우가 있는 것 같은데.. m1 칩 사용 컴퓨터에서 주로 그런 듯? 뭐가 어떻게 된 건지는 몰라도 일단 실행되었으니까 진행하자.
